# GR Core Orchestrator (Engine A) 종합 계획서

> **"DB는 도서관이고, Engine A는 사서(司書)입니다."**
>
> 아무리 좋은 책이 가득해도, 사서 없이는 원하는 책을 찾을 수 없습니다.
> Engine A는 GR 생태계의 데이터를 '가치'로 전환하는 핵심 중추입니다.

---

## 문서 정보

| 항목 | 내용 |
|------|------|
| **문서명** | GR Core Orchestrator (Engine A) 종합 계획서 |
| **버전** | v1.0 |
| **작성일** | 2025-11-27 |
| **목적** | Engine A의 존재 이유와 핵심 개념을 정립하여, 상세 설계의 기반 제공 |
| **대상 독자** | 기획자, 아키텍트, 개발팀, 경영진 |
| **연관 문서** | DB_아키텍처_설계서_v2.4.md, GR_생태계_마스터플랜_v3.1.md |

---

## 1. 서론: Engine A는 왜 존재해야 하는가?

### 1.1 현재 상황

GR 프로젝트는 3개의 서로 다른 데이터베이스를 운영합니다:

| DB | 역할 | 강점 |
|----|------|------|
| **PostgreSQL** | 정형 데이터 저장소 | ACID 트랜잭션, 복잡한 조인 |
| **Neo4j** | 관계/경로 분석 | 그래프 탐색, 공격 경로 시뮬레이션 |
| **Pinecone** | 의미 기반 검색 | 벡터 유사도, AI/RAG 연동 |

그리고 4개의 사업 영역이 이 데이터를 활용합니다:
- **GR Edu**: 보안 교육 플랫폼
- **GR Consulting**: 보안 진단 서비스
- **GR Solution**: 보안 솔루션 제품
- **GR IaC**: 보안 내장형 인프라 코드

### 1.2 Engine A 없이 발생하는 문제

만약 각 사업부가 DB에 직접 접근한다면, 다음과 같은 **4가지 치명적 문제**가 발생합니다:

#### 문제 1: 신뢰성 붕괴 (데이터 불일치)
> "진단 도구에서는 Redis가 위험하다고 했는데, 교육 자료에서는 안전하다고 합니다."

- 같은 데이터를 다른 방식으로 해석
- 사업부마다 다른 쿼리 로직 → 결과 불일치
- 고객 신뢰 상실

#### 문제 2: 수익성 악화 (비용 폭증)
> "간단한 제품 조회에도 AI API를 호출해서 월 청구서가 10배가 됐습니다."

- LLM/Vector DB 호출은 건당 비용 발생
- 단순 조회와 복잡 추론의 구분 없이 모든 요청에 AI 사용
- 매출이 늘어도 마진이 사라지는 구조

#### 문제 3: 법적 리스크 (과거 증명 불가)
> "어제 진단했을 때는 취약점이 있었는데, 고객이 패치하고는 우리 보고서가 틀렸다고 합니다."

- 모든 데이터가 '현재 시점'으로 덮어씌워짐
- 진단 당시의 상태를 증명할 방법이 없음
- 법적 분쟁에서 증거 제시 불가

#### 문제 4: 확장성 한계 (개발 병목)
> "새 사업을 시작할 때마다 DB 쿼리를 처음부터 다시 짜야 합니다."

- 복잡한 Graph/Vector 쿼리를 사업부마다 중복 개발
- 개발자가 3개 DB의 스키마를 모두 알아야 함
- Time-to-Market 지연

### 1.3 Engine A의 정의

**Engine A(GR Core Orchestrator)** 는 이 4가지 문제를 해결하기 위해 존재합니다.

```
┌─────────────────────────────────────────────────────────┐
│                    사업 엔진들                           │
│         Edu / Consulting / Solution / IaC               │
└────────────────────────┬────────────────────────────────┘
                         │ 요청/응답
                         ▼
┌─────────────────────────────────────────────────────────┐
│              GR Core Orchestrator (Engine A)            │
│                                                         │
│   "데이터의 흐름을 조율하고, 품질을 보증하며,           │
│    비용을 최적화하고, 가치를 창출하는 중앙 두뇌"        │
└────────────────────────┬────────────────────────────────┘
                         │ 최적화된 쿼리
                         ▼
┌─────────────────────────────────────────────────────────┐
│                    GR DB Cluster                         │
│           PostgreSQL / Neo4j / Pinecone                 │
└─────────────────────────────────────────────────────────┘
```

**핵심 역할**:
1. **추상화**: 사업 엔진은 데이터가 어느 DB에 있는지 알 필요 없음
2. **품질 보증**: 들어오는 데이터를 검증하고, 나가는 데이터를 일관되게 유지
3. **비용 통제**: 비싼 AI는 꼭 필요할 때만, 단순 조회는 공짜로
4. **시간 관리**: 과거의 상태를 기록하고, 언제든 복원 가능

---

## 2. 핵심 철학: Engine A의 4가지 원칙

### 원칙 1: 단일 진실의 원천 (Single Source of Truth)

> "같은 질문에는 같은 답이 나와야 합니다."

- 모든 사업 엔진은 Engine A를 통해서만 데이터에 접근
- Engine A가 데이터의 해석 기준을 통일
- 어디서 물어보든 동일한 결과 보장

**비유**: 회사에 여러 부서가 있어도, 공식 발표는 홍보팀 하나를 통해서만 나가는 것과 같습니다.

### 원칙 2: 품질 우선 (Quality First)

> "쓰레기가 들어가면 쓰레기가 나옵니다 (Garbage In, Garbage Out)."

- 데이터가 DB에 들어가기 전에 반드시 검증
- 출처(Source)별 신뢰도 점수 부여
- 충돌하는 정보는 규칙에 따라 병합

**비유**: 식당의 식재료 검수와 같습니다. 상한 재료는 아무리 요리를 잘해도 좋은 음식이 될 수 없습니다.

### 원칙 3: 비용 인식 (Cost Awareness)

> "소 잡는 칼로 닭을 잡으면 적자입니다."

- 모든 요청의 '복잡도'를 먼저 판단
- 단순 조회 → RDB/Graph (비용 $0)
- 복잡 추론 → LLM/Vector (비용 $$)
- 같은 질문이 반복되면 캐시에서 응답

**비유**: 택시와 버스를 상황에 맞게 선택하는 것과 같습니다. 급한 일에는 택시, 여유 있으면 버스.

### 원칙 4: 시간 인식 (Time Awareness)

> "보안은 상태(State)이며, 상태는 시간에 따라 변합니다."

- 모든 데이터 변경은 '언제'와 함께 기록
- 특정 시점의 상태를 언제든 복원 가능
- "진단 당시 상태"와 "현재 상태"를 구분

**비유**: 의료 차트와 같습니다. 환자의 현재 상태뿐 아니라, 언제 어떤 치료를 받았는지 이력이 필요합니다.

---

## 3. 기능 구성: Engine A의 두 축과 여섯 개의 기둥

Engine A의 기능은 **2개의 핵심 축**과 **6개의 보조 기능**으로 구성됩니다.

### 3.1 핵심 축: 데이터의 양방향 흐름

#### 축 1: 분류 엔진 (Classification Engine) - 데이터 적재

> "외부의 혼란을 내부의 질서로 바꿉니다."

**왜 필요한가?**
- 세상의 보안 정보는 제각각 다른 형식으로 존재
- Nmap 스캐너, AWS API, 수동 입력 등 소스마다 포맷이 다름
- 이를 GR Framework의 표준 체계(Layer/Zone/Tag)로 통일해야 함

**하는 일**:
1. 다양한 소스에서 데이터 수신
2. GR 표준 모델(Canonical Model)로 변환
3. 3D 좌표(Layer/Zone/Tag) 할당
4. 중복/충돌 처리 후 DB에 적재

**없다면?**
- "Redis"와 "redis", "REDIS"가 서로 다른 제품으로 인식
- 같은 서버가 소스별로 3개의 레코드로 중복 저장
- 자동화된 분석 결과의 신뢰도 붕괴

#### 축 2: 추출 엔진 (Extraction Engine) - 데이터 조회

> "질문의 의도를 파악하고, 최적의 답을 조립합니다."

**왜 필요한가?**
- 사업 엔진들은 "공격 경로 보여줘"라고 요청하지, "Neo4j의 이 노드에서 저 노드까지 BFS 탐색해줘"라고 하지 않음
- 비즈니스 언어를 기술 쿼리로 번역하는 계층 필요
- 3개 DB의 결과를 하나로 조합해야 할 때도 있음

**하는 일**:
1. 요청의 의도(Intent) 파악
2. 비즈니스 요청 → 논리 쿼리 → 물리 쿼리 변환
3. 적절한 DB에 쿼리 실행
4. 결과를 조합하여 요청자의 목적에 맞게 가공

**없다면?**
- 개발자가 3개 DB의 스키마와 쿼리 언어를 모두 알아야 함
- 사업부마다 같은 로직을 중복 개발
- 신규 기능 출시까지 개발 기간 3배 이상 증가

---

### 3.2 보조 기능: 여섯 개의 기둥

#### 기둥 1: 데이터 품질 관리 (Quality Assurance)

**문제 상황**:
> "스캐너에서 온 OS 버전은 'Linux'인데, 클라우드 API에서는 'Ubuntu 22.04'라고 합니다. 뭐가 맞죠?"

**해결책**:
- **소스별 신뢰도 점수**: Manual(1.0) > Cloud API(0.9) > Scanner(0.6)
- **교차 검증**: 내부 데이터와 외부(웹 검색) 결과 비교
- **Agreement Score**: 일치도 85% 이상이면 자동 승인, 70% 미만이면 사람에게 경보

**비즈니스 가치**:
- 오탐(False Positive) 감소 → 고객 신뢰 유지
- 데이터 정확도 70% → 99%로 향상

#### 기둥 2: 충돌 병합 (Conflict Resolution)

**문제 상황**:
> "A 소스에서는 서버 IP가 10.0.1.5인데, B 소스에서는 10.0.1.50이라고 합니다."

**해결책**:
- **필드별 우선순위**: IP는 Cloud API 기준, 버전은 Manual 기준 등
- **시간 기반 판단**: 더 최신 정보 우선
- **자동 병합 + 수동 큐**: 규칙으로 해결 안 되면 전문가 판단 요청

**비즈니스 가치**:
- "단일 진실(Golden Record)" 유지
- 데이터 중복/불일치로 인한 시스템 오류 방지

#### 기둥 3: 스냅샷 & 타임라인 (Snapshot & Timeline)

**문제 상황**:
> "고객이 진단 후 취약점을 몰래 패치하고, '너희 진단이 틀렸다'고 주장합니다."

**해결책**:
- **SCD Type 2 방식**: 데이터 변경 시 덮어쓰지 않고, 기존 레코드에 종료 시점(valid_to) 기록 후 신규 생성
- **Time Travel Query**: "2025년 1월 15일 기준 인프라 상태"를 언제든 조회 가능
- **Diff 분석**: 두 시점 간 변경사항 자동 비교

**비즈니스 가치**:
- 진단 보고서의 법적 증거 능력 확보
- 교육에서 "Before/After" 비교 시연 가능
- 컨설팅 분쟁 시 객관적 증거 제시

#### 기둥 4: 비용 최적화 라우팅 (Cost-Aware Routing)

**문제 상황**:
> "사용자가 'Redis 포트 번호 뭐야?'라고 물어봤는데, GPT-4 API를 호출해서 0.03달러가 나갔습니다."

**해결책**:
- **복잡도 분석기**: 요청이 단순 조회인지, 복잡 추론인지 판단
- **라우팅 스위치**:
  - 단순 조회 → PostgreSQL/Neo4j (비용 $0)
  - 복잡 추론 → LLM/Pinecone (비용 $$)
- **캐시 전략**: 자주 묻는 복잡 질문은 결과 캐싱

**비즈니스 가치**:
- 요청당 평균 비용 $0.02 → $0.004 (80% 절감)
- 수익률(Margin) 5배 개선
- 사용자 증가해도 비용이 비례 증가하지 않음

#### 기둥 5: 컨텍스트 라우터 (Context Router)

**문제 상황**:
> "교육 플랫폼 사용자가 실수로 컨설팅 고객사의 실제 취약점 정보를 조회했습니다."

**해결책**:
- **테넌트 격리**: 요청자의 소속(tenant_id)에 따라 접근 가능 데이터 제한
- **의도 기반 마스킹**:
  - 교육용(Edu) → 실제 IP를 192.168.x.x로 가림
  - 진단용(Consulting) → 모든 Raw Data 노출
- **목적별 뷰**: 같은 데이터도 요청 목적에 따라 다른 형태로 제공

**비즈니스 가치**:
- 데이터 유출 사고 방지
- 하나의 DB로 여러 사업 운영 가능 (인프라 비용 절감)
- 규제 준수 (데이터 격리 요건 충족)

#### 기둥 6: 능동형 학습 루프 (Active Learning Loop)

**문제 상황**:
> "새로 나온 오픈소스 'Valkey'가 들어왔는데, DB에 없어서 분류가 안 됩니다."

**해결책**:
- **Unknown Collector**: 분류 실패 데이터를 에러가 아닌 '학습 기회'로 수집
- **AI 자동 라벨링**: LLM에게 "이 제품의 Layer/Zone/Tag를 추론해줘" 요청
- **Human-in-the-loop**: AI 제안을 전문가가 검토 후 승인
- **카탈로그 자동 업데이트**: 승인된 정보로 DB 확장 → 다음부터 자동 분류

**비즈니스 가치**:
- 데이터 입력 인력 비용 절감
- DB가 시간이 지날수록 스스로 성장
- 새로운 기술 트렌드에 자동 대응

---

## 4. 가치 제안: Engine A가 만드는 변화

### 4.1 정량적 효과 (ROI)

| 구분 | 지표 | Before (Engine A 없음) | After (Engine A 도입) | 개선 효과 |
|------|------|------------------------|----------------------|-----------|
| **비용** | 요청당 평균 비용 | $0.02 (무조건 AI) | $0.004 (최적화) | **80% 절감** |
| **품질** | 데이터 정확도 | 70% | 99% | **신뢰도 향상** |
| **속도** | 신규 기능 배포 | 4주 | 3일 | **13배 빠름** |
| **리스크** | 과거 증빙 능력 | 불가능 | 100% 가능 | **분쟁 방어** |

### 4.2 정성적 효과

#### 개발팀 관점
- 3개 DB 스키마를 몰라도 개발 가능
- 복잡한 쿼리 대신 템플릿 호출
- 보안/품질이 기본 내장

#### 사업팀 관점
- 새 사업 아이템 출시 속도 향상
- 데이터 불일치로 인한 고객 클레임 감소
- 프리미엄 데이터 서비스 과금 가능

#### 경영진 관점
- 인력 중심 → 플랫폼 중심 비즈니스 전환
- 한계 비용(Marginal Cost) 최소화
- 확장 가능한(Scalable) 수익 구조

---

## 5. 구현 전략: 단계별 접근

### Phase 1: 기반 구축 (Foundation)

**목표**: 데이터가 들어오고 나갈 수 있는 기본 파이프라인

**구성 요소**:
- 분류 엔진 (기본 좌표 할당)
- 추출 엔진 (단순 조회 통합)
- 스키마 레지스트리 (메타데이터 관리)

**성공 기준**:
- "제품명 입력 → Layer/Zone/Tag 자동 할당"이 동작
- "사업 엔진이 DB 종류 모르고 데이터 조회 가능"

### Phase 2: 거버넌스 구축 (Governance)

**목표**: 데이터 품질과 접근 통제

**구성 요소**:
- 비용 최적화 라우터 (최우선: 돈 새는 것 방지)
- 데이터 품질(QA) 엔진
- 충돌 병합 엔진
- 컨텍스트 라우터 (기본 테넌트 격리)

**성공 기준**:
- "단순 조회는 AI 호출 없이 처리"
- "동일 자산의 중복 데이터 자동 병합"

### Phase 3: 지능화 (Intelligence)

**목표**: 시스템이 스스로 성장하고 최적화

**구성 요소**:
- 스냅샷 & 타임라인 엔진
- 능동형 학습 루프
- 시나리오 템플릿 엔진
- 관측 & 미터링

**성공 기준**:
- "특정 시점의 인프라 상태 복원 가능"
- "미등록 제품이 들어오면 AI가 분류 제안"

### Phase 4: 수익화 (Monetization)

**목표**: 외부 API 공개 및 가치 기반 과금

**구성 요소**:
- Value-Based Billing (정보 가치에 따른 과금)
- 파트너 등급별 접근 제어
- 사용량 대시보드

**성공 기준**:
- "단순 조회 1 Credit, 공격 경로 시뮬레이션 50 Credits"
- "파트너 등급에 따라 데이터 깊이 차등 제공"

---

## 6. 리스크 및 대응 방안

### 리스크 1: 단일 장애점 (Single Point of Failure)

**우려**: Engine A가 모든 요청을 처리하므로, 장애 시 전체 시스템 마비

**대응**:
- 상태 비저장(Stateless) 설계로 수평 확장 가능하게 구현
- 핵심 모듈 분리 배포 (분류 엔진과 추출 엔진 독립 운영)
- 회로 차단기(Circuit Breaker) 패턴 적용

### 리스크 2: 학습 루프의 스키마 오염

**우려**: AI가 잘못된 분류를 제안하고, 무분별하게 승인되면 DB 품질 저하

**대응**:
- 완전 자동화 대신 Human-in-the-loop 필수
- Unknown 데이터 중 빈도/중요도 높은 것만 우선 처리
- 승인된 분류도 주기적으로 품질 감사

### 리스크 3: 비용 최적화 룰의 정확도

**우려**: 복잡한 요청을 단순으로 판단하여 품질 저하, 또는 그 반대로 비용 증가

**대응**:
- 초기에는 보수적으로 운영 (애매하면 AI 사용)
- 로그 분석을 통해 점진적으로 룰 정교화
- 사용자 피드백("결과가 부족했다")을 룰 개선에 반영

---

## 7. 결론: Engine A의 본질

### 7.1 비유로 이해하기

Engine A를 여러 비유로 설명할 수 있습니다:

| 비유 | 설명 |
|------|------|
| **사서(司書)** | 도서관의 책(데이터)을 분류하고, 독자의 질문에 맞는 책을 찾아줌 |
| **번역가** | 비즈니스 언어를 기술 언어로, 기술 결과를 비즈니스 가치로 번역 |
| **품질 관리자** | 들어오는 재료(데이터)를 검수하고, 불량품을 걸러냄 |
| **재무 이사** | 비용과 가치를 계산하여, 최적의 자원 배분 결정 |
| **역사가** | 과거의 상태를 기록하고, 필요할 때 복원 |

### 7.2 한 문장 정의

> **"Engine A는 GR 생태계의 데이터가 '원석'에서 '보석'으로 정제되는 공장이며, 그 과정에서 품질, 비용, 시간, 보안을 모두 관리하는 통합 제어탑입니다."**

### 7.3 왜 지금 필요한가?

1. **사업 확장 전에**: 여러 사업이 같은 DB를 쓰기 시작하면, 나중에 중앙 제어 도입이 100배 어려워짐
2. **데이터가 쌓이기 전에**: 품질 관리 없이 쌓인 데이터는 정화 비용이 기하급수적
3. **비용이 커지기 전에**: AI 비용은 사용량에 비례. 최적화 없이 성장하면 적자 구조

---

## 부록: 용어 정의

| 용어 | 정의 |
|------|------|
| **3D Framework** | Layer(배치 계층) × Zone(보안 영역) × Tag(기능 분류)로 구성된 GR의 인프라 분류 체계 |
| **Canonical Model** | 다양한 소스의 데이터를 통일된 형식으로 변환한 표준 모델 |
| **Golden Record** | 여러 소스의 데이터가 병합된 후 최종 확정된 "단일 진실" 레코드 |
| **Agreement Score** | 내부/외부 데이터 일치도를 0~1로 수치화한 신뢰도 점수 |
| **SCD Type 2** | Slowly Changing Dimension Type 2. 데이터 변경 시 이력을 보존하는 방식 |
| **Human-in-the-loop** | AI의 판단을 사람이 최종 검토/승인하는 프로세스 |

---

## 다음 단계

이 종합 계획서를 기반으로 다음 문서들이 작성되어야 합니다:

1. **상세 설계서**: 각 모듈의 내부 구조, 인터페이스, 데이터 흐름
2. **API 명세서**: 요청/응답 포맷, 엔드포인트, 에러 코드
3. **DB 스키마 확장안**: Engine A 지원을 위해 추가할 테이블/컬럼
4. **구현 로드맵**: Phase별 일정, 담당자, 마일스톤

---

**[문서 끝]**
